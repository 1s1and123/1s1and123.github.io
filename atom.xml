<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Island&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://island123.github.io/"/>
  <updated>2020-02-21T16:44:00.801Z</updated>
  <id>https://island123.github.io/</id>
  
  <author>
    <name>Island</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IOT环境搭建--如何使用qemu运行各种指令架构程序</title>
    <link href="https://island123.github.io/2020/02/12/IOT%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA--%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8qemu%E8%BF%90%E8%A1%8C%E5%90%84%E7%A7%8D%E6%8C%87%E4%BB%A4%E6%9E%B6%E6%9E%84%E7%A8%8B%E5%BA%8F/"/>
    <id>https://island123.github.io/2020/02/12/IOT%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA--%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8qemu%E8%BF%90%E8%A1%8C%E5%90%84%E7%A7%8D%E6%8C%87%E4%BB%A4%E6%9E%B6%E6%9E%84%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2020-02-21T16:44:00.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOT环境搭建–如何使用qemu运行各种指令架构程序"><a href="#IOT环境搭建–如何使用qemu运行各种指令架构程序" class="headerlink" title="IOT环境搭建–如何使用qemu运行各种指令架构程序"></a>IOT环境搭建–如何使用qemu运行各种指令架构程序</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>考虑到性能等因素,<code>IoT</code>设备往往采用<code>arm</code> , <code>mips</code>等指令架构,还有少量采取<code>ppc</code> <code>x86</code>等,在<code>IOT</code>分析中,往往需要使用硬件虚拟化的虚拟机<code>qemu</code>来实现针对不同指令架构程序的仿真模拟.</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在<code>IoT</code>分析中,一些情况下只需要在用户模式下针对单个的程序进行仿真,另一些情况则需要建立一个完整的对应指令架构的虚拟机.以下是针对性的解决方案.</p><h3 id="使用qemu-user运行不同指令架构程序"><a href="#使用qemu-user运行不同指令架构程序" class="headerlink" title="使用qemu-user运行不同指令架构程序"></a>使用<code>qemu-user</code>运行不同指令架构程序</h3><h4 id="qemu-user安装"><a href="#qemu-user安装" class="headerlink" title="qemu-user安装"></a><code>qemu-user</code>安装</h4><p><code>$ sudo apt-get install qemu qemu-user qemu-user-static</code></p><h4 id="qemu-user使用"><a href="#qemu-user使用" class="headerlink" title="qemu-user使用"></a><code>qemu-user</code>使用</h4><p>此时可以运行静态链接的<code>arm</code>程序:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file ./arm_static</span><br><span class="line">./arm_static: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped    </span><br><span class="line">$ qemu-arm ./arm_static</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></div><p>而要运行动态链接的程序，需要安装对应架构的动态链接库方可,例如以下这个<code>arm64</code>程序：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file ./arm64_shared</span><br><span class="line">./arm64_shared: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux 3.7.0, BuildID[sha1]=e988eaee79fd41139699d813eac0c375dbddba43, stripped</span><br></pre></td></tr></table></figure></div><p>要首先安装对应架构<code>arm64</code>的汇编器及动态链接库:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install binutils-aarch64-linux-gnu</span><br><span class="line">$ sudo apt install libc6-arm64-cross</span><br></pre></td></tr></table></figure></div><p>其中具体的汇编器和动态链接库可以通过以下命令进行查找:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt search binutils| grep aarch64</span><br><span class="line">$ sudo apt-cache search “libc6-” | grep “arm”</span><br></pre></td></tr></table></figure></div><p>然后就可以实现该程序的仿真:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-aarch64 -L /usr/aarch64-linux-gnu ./arm64_shared</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></div><p>其它架构处理类似.</p><h3 id="使用qemu搭建不同指令架构虚拟机"><a href="#使用qemu搭建不同指令架构虚拟机" class="headerlink" title="使用qemu搭建不同指令架构虚拟机"></a>使用<code>qemu</code>搭建不同指令架构虚拟机</h3><p>使用<code>qemu</code>搭建不同指令架构虚拟机可以有两种方式:</p><ol><li>下载对应指令架构的内核和文件系统,然后使用<code>qemu-system</code>建立相应指令架构的虚拟机,但是这种方法需要配置好虚拟机网络</li><li>直接使用<code>docker</code>运行各种指令架构的容器</li></ol><h4 id="使用qemu-system建立不同指令架构虚拟机"><a href="#使用qemu-system建立不同指令架构虚拟机" class="headerlink" title="使用qemu-system建立不同指令架构虚拟机"></a>使用<code>qemu-system</code>建立不同指令架构虚拟机</h4><h5 id="qemu-system安装"><a href="#qemu-system安装" class="headerlink" title="qemu-system安装"></a><code>qemu-system</code>安装</h5><p><code>$ sudo apt-get install qemu qemu-user-static qemu-system uml-utilities bridge-utils</code></p><p>使用<code>qemu-system</code>可模拟完整的各种指令架构的<code>linux</code>系统</p><h5 id="虚拟机建立步骤"><a href="#虚拟机建立步骤" class="headerlink" title="虚拟机建立步骤"></a>虚拟机建立步骤</h5><ul><li><p>配置虚拟机网络</p><p>安装依赖文件</p><p><code>sudo apt-get install bridge-utils uml-utilities</code></p><p>修改 ubuntu主机网络配置，将ubuntu主机系统中的网络接口配置文件 <strong>/etc/network/interfaces</strong> 修改为如下内容并保存、关闭。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">auto eth0 </span><br><span class="line">iface eth0 inet dhcp </span><br><span class="line"> </span><br><span class="line"><span class="comment">#auto br0 </span></span><br><span class="line">iface br0 inet dhcp </span><br><span class="line">  bridge_ports eth0 </span><br><span class="line">  bridge_maxwait 0</span><br></pre></td></tr></table></figure></div><p>创建QEMU的网络接口启动脚本，重启网络使配置生效。使用如下命令，在 <strong>/etc/qemu-ifup</strong>的后面加入以下内容。</p><p><code>sudo gedit /etc/qemu-ifup</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Executing /etc/qemu-ifup"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Bringing <span class="variable">$1</span> for bridged mode..."</span></span><br><span class="line">sudo /sbin/ifconfig <span class="variable">$1</span> 0.0.0.0 promisc up</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Adding <span class="variable">$1</span> to br0..."</span></span><br><span class="line">sudo /sbin/brctl addif br0 <span class="variable">$1</span></span><br><span class="line">sleep 3</span><br></pre></td></tr></table></figure></div><p>保存 文件/etc/qemu-ifup 以后，赋予文件/etc/qemu-ifup 可执行权限，然后重启网络使所有的配置生效。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod a+x /etc/qemu-ifup</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重启网络使配置生效</span></span><br><span class="line">$ sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure></div><p>在本地ubuntu命令行终端，启动桥连网络。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifdown eth0</span><br><span class="line">sudo ifup br0</span><br></pre></td></tr></table></figure></div></li><li><p>下载虚拟机内核文件系统文件</p><p>可以在以下地址下载:</p><p><a href="https://people.debian.org/~aurel32/qemu/" target="_blank" rel="noopener">下载地址：https://people.debian.org/~aurel32/qemu/</a></p><p>当然也可以自己编译对应架构内核.</p></li><li><p>各架构虚拟机开启命令</p><p>下载好各种架构的内核文件和系统文件后运行以下命令即可打开对应指令架构的虚拟机</p><p><strong>mips 32位：</strong>  </p><p><code>qemu-system-mips -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code> </p><p><strong>mips 64位：</strong>  </p><p><code>qemu-system-mips64 -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code>  </p><p><strong>mipsel 32位：</strong>  </p><p><code>qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code></p><p><strong>mipsel 64位</strong>  </p><p><code>qemu-system-mips64el -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code></p><p><strong>armel</strong></p><p><code>qemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_standard.qcow2 -append &quot;root=/dev/sda1&quot; -net nic -net tap -nographic</code></p><p><strong>armhf</strong></p><p><code>qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append &quot;root=/dev/mmcblk0p2&quot; -net nic -net tap -nographic</code></p><p><strong>arm64</strong></p><p><code>qemu-system-x86_64 -hda debian_wheezy_amd64_standard.qcow2 -net nic -net tap -nographic</code></p></li></ul><h5 id="与docker的兼容性问题"><a href="#与docker的兼容性问题" class="headerlink" title="与docker的兼容性问题"></a>与<code>docker</code>的兼容性问题</h5><p>安装了<code>docker</code>后，可能会发现<code>qemu</code>开启的虚拟机无法正常联网了，这是因为<code>docker</code>安装中更改了<code>iptables</code>,可执行一下命令更正一下路由表</p><p><code>iptables -I FORWARD -i br0 -o br0 -j ACCEPT</code></p><p>然而这是临时生效，下次重启还需要重新执行，可按以下方法一劳永逸：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install iptables-persistent</span><br><span class="line">$ sudo netfilter-persistent save</span><br><span class="line">$ sudo netfilter-persistent reload</span><br></pre></td></tr></table></figure></div><p>另外可能还需要修改<code>DNS</code>:</p><p><code>$ cp  /etc/resolv.conf   /etc/resolv.confbak</code></p><p>将<code>/etc/resolv.conf</code>内容更改为以下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8   #设置首选dns</span><br><span class="line">nameserver 8.8.4.4   #设置备用dns</span><br></pre></td></tr></table></figure></div><h4 id="使用docker建立不同指令架构虚拟机"><a href="#使用docker建立不同指令架构虚拟机" class="headerlink" title="使用docker建立不同指令架构虚拟机"></a>使用<code>docker</code>建立不同指令架构虚拟机</h4><h5 id="安装qemu环境"><a href="#安装qemu环境" class="headerlink" title="安装qemu环境"></a>安装<code>qemu</code>环境</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qemu qemu-user-static qemu-system uml-utilities bridge-utils</span><br></pre></td></tr></table></figure></div><h5 id="下载镜像-armhf为例"><a href="#下载镜像-armhf为例" class="headerlink" title="下载镜像(armhf为例)"></a>下载镜像(<code>armhf</code>为例)</h5><p><code>$ docker pull ioft/armhf-ubuntu:trusty</code></p><p>其它架构类似,直接<code>search</code>即可</p><h5 id="使用docker运行容器-armhf为例"><a href="#使用docker运行容器-armhf为例" class="headerlink" title="使用docker运行容器(armhf为例)"></a>使用docker运行容器(<code>armhf</code>为例)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --privileged -v &#x2F;usr&#x2F;bin&#x2F;qemu-arm-static:&#x2F;usr&#x2F;bin&#x2F;qemu-arm-static ioft&#x2F;armhf-ubuntu:trusty &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></div><p>进入容器查看</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -it 240f58b9b3ba bash</span><br><span class="line">root@240f58b9b3ba:/<span class="comment"># uname -a</span></span><br><span class="line">Linux 240f58b9b3ba 4.4.0-171-generic <span class="comment">#200-Ubuntu SMP Tue Dec 3 11:04:55 UTC 2019 armv7l armv7l armv7l GNU/Linux</span></span><br><span class="line">root@240f58b9b3ba:/<span class="comment"># file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=74480e1a4f4c0aebebd4db4f5405e720cf4b8de5, stripped</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IOT环境搭建–如何使用qemu运行各种指令架构程序&quot;&gt;&lt;a href=&quot;#IOT环境搭建–如何使用qemu运行各种指令架构程序&quot; class=&quot;headerlink&quot; title=&quot;IOT环境搭建–如何使用qemu运行各种指令架构程序&quot;&gt;&lt;/a&gt;IOT环境搭建–
      
    
    </summary>
    
    
      <category term="工具学习" scheme="https://island123.github.io/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="环境搭建" scheme="https://island123.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="qemu" scheme="https://island123.github.io/tags/qemu/"/>
    
      <category term="docker" scheme="https://island123.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>2019-06-11-使用SSH搭建代理及端口转发</title>
    <link href="https://island123.github.io/2020/01/07/2019-06-11-%E4%BD%BF%E7%94%A8SSH%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>https://island123.github.io/2020/01/07/2019-06-11-%E4%BD%BF%E7%94%A8SSH%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</id>
    <published>2020-01-07T04:42:43.892Z</published>
    <updated>2020-01-07T05:18:04.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用SSH搭建代理及端口转发"><a href="#使用SSH搭建代理及端口转发" class="headerlink" title="使用SSH搭建代理及端口转发"></a>使用SSH搭建代理及端口转发</h1><hr><p>layout:     post<br>title:     使用SSH搭建代理及端口转发<br>subtitle:<br>date:       2019-06-11<br>author:     Island<br>categories:</p><ul><li>工具学习<br>tags:<ul><li>环境配置</li><li>代理</li><li>ssh</li></ul></li></ul><h2 id="搭建代理"><a href="#搭建代理" class="headerlink" title="搭建代理"></a>搭建代理</h2><p>以下操作皆在本地win下完成</p><ul><li><p>开启端口转发</p><p><code>ssh -N -D 127.0.0.1:&lt;local_port&gt; root@&lt;server_ip&gt; -p &lt;server_ssh_port&gt;</code></p></li></ul><ul><li><p>在chrome中下载<code>Proxy switchyOmega</code>,新建一个配置<code>socks5</code>代理位本地ip加端口，如下：</p><p>首先添加一个ss直接代理：</p><p><a href="2019-06-11-%E4%BD%BF%E7%94%A8SSH%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.assets/1560328699626.png" data-fancybox="group" data-caption="1560328699626" class="fancybox"><img alt="1560328699626" title="1560328699626" data-src="2019-06-11-%E4%BD%BF%E7%94%A8SSH%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.assets/1560328699626.png" class="lazyload"></a></p><p>再按如下图添加一个自动切换模式：</p><p>附上规则列表链接<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code></p><p><a href="2019-06-11-%E4%BD%BF%E7%94%A8SSH%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.assets/1560415385308.png" data-fancybox="group" data-caption="1560415385308" class="fancybox"><img alt="1560415385308" title="1560415385308" data-src="2019-06-11-%E4%BD%BF%E7%94%A8SSH%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E5%8F%8A%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.assets/1560415385308.png" class="lazyload"></a></p></li></ul><p>配置完成，需要操作时在chrome切换到对应模式即可</p><h2 id="将内网端口投送至外网"><a href="#将内网端口投送至外网" class="headerlink" title="将内网端口投送至外网"></a>将内网端口投送至外网</h2><p>现在假定机器A为内网机器，B为有公网ip的机器。</p><ul><li><p>在内网机器A中执行以下命令：</p><p><code>sudo apt-get install autossh</code></p><p><code>autossh -M 5678 -NCR &lt;port_1&gt;:localhost:22 root@&lt;server_ip&gt; -p &lt;server_ssh_port&gt;</code></p><p>其中 <code>&lt;port_1&gt;</code>为B机器中一个空闲端口，执行完这句命令便将A机器的22端口投送在B机器的<port_1>上。另外，我这里使用了autossh是为了保证ssh连接的可靠性。</port_1></p><p>执行完这个命令后，在B机器上ssh连接其<port_1>端口以及可以正常连接，但是要在别的机器上连接还不行，还需要将这个端口再转发到B机器上另外一个端口才可以</port_1></p></li><li><p>在公网机器B中执行以下命令：</p><p><code>ssh -fCNL *:&lt;port_2&gt;:localhost:&lt;port_1&gt; localhost -p &lt;server_ssh_port&gt;</code></p><p>执行完本命令后，便可使用ssh连接B机器的<port_2>端口进而来连接A机器的22端口。</port_2></p></li><li><p>如果要做成开启启动，可将以上脚本添加至<code>/etc/rc.local</code>脚本中。另外不止22端口，任意端口的投送应该都是可以的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用SSH搭建代理及端口转发&quot;&gt;&lt;a href=&quot;#使用SSH搭建代理及端口转发&quot; class=&quot;headerlink&quot; title=&quot;使用SSH搭建代理及端口转发&quot;&gt;&lt;/a&gt;使用SSH搭建代理及端口转发&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;layout:     post&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sqlmap 简要使用</title>
    <link href="https://island123.github.io/2019/03/15/2019-03-15-Sqlmap-%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8/"/>
    <id>https://island123.github.io/2019/03/15/2019-03-15-Sqlmap-%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8/</id>
    <published>2019-03-14T16:00:00.000Z</published>
    <updated>2020-01-07T05:17:50.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqlmap-简要使用"><a href="#sqlmap-简要使用" class="headerlink" title="sqlmap 简要使用"></a>sqlmap 简要使用</h1><ul><li>查询现用的数据库<ul><li><code>python .\sqlmap.py -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; --current-db</code></li></ul></li><li>查询数据库中my_db所有表<ul><li><code>python .\sqlmap.py -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db --tables</code></li></ul></li><li>查询数据库my_db中thiskey表中所有列<ul><li><code>python .\sqlmap.py -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey --columns</code></li></ul></li><li>查询数据库my_db中thiskey表中k0y的值所有列<ul><li><code>python .\sqlmap.py -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey -C k0y --dump</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqlmap-简要使用&quot;&gt;&lt;a href=&quot;#sqlmap-简要使用&quot; class=&quot;headerlink&quot; title=&quot;sqlmap 简要使用&quot;&gt;&lt;/a&gt;sqlmap 简要使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;查询现用的数据库&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pytho
      
    
    </summary>
    
    
      <category term="工具学习" scheme="https://island123.github.io/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="sqlmap" scheme="https://island123.github.io/tags/sqlmap/"/>
    
      <category term="sql注入" scheme="https://island123.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
      <category term="数据库" scheme="https://island123.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用buildroot交叉编译不同指令架构 gdb/gdbserver</title>
    <link href="https://island123.github.io/2019/03/15/2019-03-15-%E4%BD%BF%E7%94%A8buildroot%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E6%8C%87%E4%BB%A4%E6%9E%B6%E6%9E%84-gdbgdbserver/"/>
    <id>https://island123.github.io/2019/03/15/2019-03-15-%E4%BD%BF%E7%94%A8buildroot%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E6%8C%87%E4%BB%A4%E6%9E%B6%E6%9E%84-gdbgdbserver/</id>
    <published>2019-03-14T16:00:00.000Z</published>
    <updated>2020-01-07T05:17:54.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交叉编译不同指令架构-gdb-gdbserver"><a href="#交叉编译不同指令架构-gdb-gdbserver" class="headerlink" title="交叉编译不同指令架构 gdb/gdbserver"></a>交叉编译不同指令架构 gdb/gdbserver</h1><h2 id="一、运行环境对内核版本无要求"><a href="#一、运行环境对内核版本无要求" class="headerlink" title="一、运行环境对内核版本无要求"></a>一、运行环境对内核版本无要求</h2><p><strong>以mips64为例，其他架构类似</strong></p><ul><li>wget <a href="https://ftp.gnu.org/gnu/gdb/gdb-7.11.tar.gz" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/gdb/gdb-7.11.tar.gz</a></li><li>tar -xvf gdb-7.11.tar.gz</li><li>cd gdb-7.11</li><li>sudo apt-get install gcc-mips64-linux-gnuabi64</li><li>./configure –host=mips64-linux  CC=mips64-linux-gnuabi64-gcc LD=mips64-linux-gnuabi64-ld AR=mips64-linux-gnuabi64-ar LDFLAGS=”-static” –prefix=/home/gdbnew/mips64-gdb<ul><li>CC LD  AR等均需指定为mips64交叉编译器</li><li>LDFLAGS指定为静态编译</li><li>–prefix指定生成的二进制存放的路径</li></ul></li></ul><blockquote><p>本做法是可以成功编译出gdb以及gdbserver,但是我将其放到目标设备上运行时会出现“Kernel too old”的错误，猜测应该是编译二进制的交叉编译工具的内核版本太高，和目标运行环境不适配</p></blockquote><h2 id="二、使用指定内核以及libc版本"><a href="#二、使用指定内核以及libc版本" class="headerlink" title="二、使用指定内核以及libc版本"></a>二、使用指定内核以及libc版本</h2><p><strong>以mips64为例，其他架构类似</strong></p><ul><li><p>下载安装配置buildroot</p><p>安装依赖</p><ul><li>apt-get install gcc build-essential bison flex gettext tcl sharutils libncurses-dev zlib1g-dev exuberant-ctags g++ texinfo patch vim libtool bc</li></ul><p>下载源码</p><ul><li>git clone https:<em>//github.com/buildroot/buildroot.git</em></li></ul><p>进行编译的配置</p><ul><li>cd buildroot</li><li>make clean</li><li>make menuconfig </li><li>在图形界面对内核版本以及libc等进行合理配置</li><li>make</li></ul><p>编译完成后在<strong>buildroot/output/host/usr/bin</strong>目录下可以看到交叉编译工具，mips64的编译器就是该目录下的<strong>mips64-linux-gcc</strong></p></li><li><p>编译gdb/gdbserver</p><ul><li>wget <a href="https://ftp.gnu.org/gnu/gdb/gdb-7.11.tar.gz" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/gdb/gdb-7.11.tar.gz</a></li><li>tar -xvf gdb-7.11.tar.gz</li><li>cd gdb-7.11</li><li>./configure –host=mips64-linux  CC=mips64-linux-gcc LD=mips64-linux-ld AR=mips64-linux-ar LDFLAGS=”-static” <ul><li>CC LD AR等均需指定为buildroot生成的mips64交叉编译器</li><li>LDFLAGS指定为静态编译</li><li>–prefix指定生成的二进制存放的路径</li></ul></li><li>make</li><li>make install</li></ul></li></ul><blockquote><p>本方法编译出的gdb/gdbserver可以指定交叉编译工具的内核版本，不会出现内核不适配这样的问题，但buildroot编译出交叉编译工具的时间可能比较长</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;交叉编译不同指令架构-gdb-gdbserver&quot;&gt;&lt;a href=&quot;#交叉编译不同指令架构-gdb-gdbserver&quot; class=&quot;headerlink&quot; title=&quot;交叉编译不同指令架构 gdb/gdbserver&quot;&gt;&lt;/a&gt;交叉编译不同指令架构 gdb
      
    
    </summary>
    
    
      <category term="工具学习" scheme="https://island123.github.io/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="gdb" scheme="https://island123.github.io/tags/gdb/"/>
    
      <category term="gdbserver" scheme="https://island123.github.io/tags/gdbserver/"/>
    
      <category term="交叉编译" scheme="https://island123.github.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="buildroot" scheme="https://island123.github.io/tags/buildroot/"/>
    
      <category term="mips64" scheme="https://island123.github.io/tags/mips64/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用简要教程</title>
    <link href="https://island123.github.io/2019/03/14/2019-03-14-Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/"/>
    <id>https://island123.github.io/2019/03/14/2019-03-14-Docker%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2020-01-07T05:16:49.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><p>Ubuntu 16.04 X64</p><h2 id="2-获取镜像："><a href="#2-获取镜像：" class="headerlink" title="2. 获取镜像："></a>2. 获取镜像：</h2><h3 id="从docker镜像站仓库获取镜像的命令如下："><a href="#从docker镜像站仓库获取镜像的命令如下：" class="headerlink" title="从docker镜像站仓库获取镜像的命令如下："></a>从docker镜像站仓库获取镜像的命令如下：</h3><blockquote><p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p></blockquote><p>比如：  </p><blockquote><p>$ docker pull ubuntu:16.04<br>16.04: Pulling from library/ubuntu<br>bf5d46315322: Pull complete<br>9f13e0ac480c: Pull complete<br>e8988b5b3097: Pull complete<br>40af181810e7: Pull complete<br>e6f7c7e5c03e: Pull complete<br>Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe<br>Status: Downloaded newer image for ubuntu:16.04</p></blockquote><h2 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:16.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令： </p><blockquote><p>$ docker run -it –rm \<br>    ubuntu:16.04 \<br>    bash</p></blockquote><p>root@e7009c6ce357:/# cat /etc/os-release<br>NAME=”Ubuntu”<br>VERSION=”16.04.4 LTS, Trusty Tahr”<br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=”Ubuntu 16.04.4 LTS”<br>VERSION_ID=”16.04”<br>HOME_URL=”<a href="http://www.ubuntu.com/&quot;" target="_blank" rel="noopener">http://www.ubuntu.com/&quot;</a><br>SUPPORT_URL=”<a href="http://help.ubuntu.com/&quot;" target="_blank" rel="noopener">http://help.ubuntu.com/&quot;</a><br>BUG_REPORT_URL=”<a href="http://bugs.launchpad.net/ubuntu/&quot;" target="_blank" rel="noopener">http://bugs.launchpad.net/ubuntu/&quot;</a>  </p><p>docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数:</p><ul><li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li><li>ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。</li><li>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。<br>进入容器后，我们可以在 Shell下操作，执行任何所需的命令。<br>这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。</li><li>最后我们通过 exit 退出了这个容器。<h2 id="3-列出镜像"><a href="#3-列出镜像" class="headerlink" title="3. 列出镜像"></a>3. 列出镜像</h2>要想展示已经下载好的镜像，可以使用docker image ls命令：<blockquote><p>$ docker image ls<br>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br>redis                latest              5f515359c7f8        5 days ago          183 MB<br>nginx                latest              05a60462f8ba        5 days ago          181 MB<br>mongo                3.2                 fe9198c04d62        5 days ago          342 MB  </p></blockquote></li></ul><p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。<br>镜像ID是镜像的唯一标识，一个镜像可能有多个标签。</p><h2 id="4-删除镜像"><a href="#4-删除镜像" class="headerlink" title="4. 删除镜像"></a>4. 删除镜像</h2><p>如果要删除本地镜像，可以使用docker image rm命令，其格式为：</p><blockquote><p>$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1. 环境&quot;&gt;&lt;/a&gt;1. 环境&lt;/h2&gt;&lt;p&gt;Ubuntu 16.04 X64&lt;/p&gt;
&lt;h2 id=&quot;2-获取镜像：&quot;&gt;&lt;a href=&quot;#2-获取镜像：&quot; cla
      
    
    </summary>
    
    
      <category term="工具学习" scheme="https://island123.github.io/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker" scheme="https://island123.github.io/tags/Docker/"/>
    
      <category term="环境搭建" scheme="https://island123.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="虚拟机" scheme="https://island123.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Docker ce流程</title>
    <link href="https://island123.github.io/2019/03/14/2019-03-14-Ubuntu%E5%AE%89%E8%A3%85Docker-ce%E6%B5%81%E7%A8%8B/"/>
    <id>https://island123.github.io/2019/03/14/2019-03-14-Ubuntu%E5%AE%89%E8%A3%85Docker-ce%E6%B5%81%E7%A8%8B/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2020-01-07T05:17:27.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu安装Docker-ce流程"><a href="#Ubuntu安装Docker-ce流程" class="headerlink" title="Ubuntu安装Docker ce流程"></a>Ubuntu安装Docker ce流程</h2><p>实际操作中发现，Docker对32位系统支持并不好，对于Win10自带的ubuntu貌似也会出一点问题。尝试之后本人决定使用Ubuntu 16.04。</p><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h4><h5 id="卸载旧版本："><a href="#卸载旧版本：" class="headerlink" title="卸载旧版本："></a>卸载旧版本：</h5><blockquote><p>$ sudo apt-get remove docker <br>               docker-engine <br>               docker.io</p></blockquote><h5 id="Ubuntu-14-04-可选内核模块-16-04版本无需本步-："><a href="#Ubuntu-14-04-可选内核模块-16-04版本无需本步-：" class="headerlink" title="Ubuntu 14.04 可选内核模块(16.04版本无需本步)："></a>Ubuntu 14.04 可选内核模块(16.04版本无需本步)：</h5><blockquote><p>$ sudo apt-get update</p><p>$ sudo apt-get install <br>    linux-image-extra-$(uname -r) <br>    linux-image-extra-virtual</p></blockquote><h4 id="2-使用-APT安装"><a href="#2-使用-APT安装" class="headerlink" title="2. 使用 APT安装"></a>2. 使用 APT安装</h4><h5 id="添加https传输支持："><a href="#添加https传输支持：" class="headerlink" title="添加https传输支持："></a>添加https传输支持：</h5><blockquote><p>$ sudo apt-get update</p></blockquote><blockquote><p>$ sudo apt-get install \<br>    apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    software-properties-common</p></blockquote><blockquote><p>$ curl -fsSL <a href="https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg</a> | sudo apt-key add -</p></blockquote><h5 id="向-source-list-中添加-Docker-软件源："><a href="#向-source-list-中添加-Docker-软件源：" class="headerlink" title="向 source.list 中添加 Docker 软件源："></a>向 source.list 中添加 Docker 软件源：</h5><blockquote><p>sudo add-apt-repository \<br>    “deb [arch=amd64] <a href="https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu</a> \<br>    $(lsb_release -cs) \<br>    stable”</p></blockquote><h4 id="3-安装-Docker-CE"><a href="#3-安装-Docker-CE" class="headerlink" title="3. 安装 Docker CE"></a>3. 安装 Docker CE</h4><blockquote><p>$ sudo apt-get update</p></blockquote><blockquote><p>$ sudo apt-get install docker-ce</p></blockquote><h4 id="4-启动docker-ce"><a href="#4-启动docker-ce" class="headerlink" title="4. 启动docker-ce"></a>4. 启动docker-ce</h4><blockquote><p>$ sudo systemctl enable docker<br>$ sudo systemctl start docker</p></blockquote><p>如果是14.04，使用以下命令启动：</p><blockquote><p>$ sudo service docker start</p></blockquote><h4 id="5-建立-docker-用户组"><a href="#5-建立-docker-用户组" class="headerlink" title="5. 建立 docker 用户组"></a>5. 建立 docker 用户组</h4><blockquote><p>$ sudo groupadd docker<br>$ sudo usermod -aG docker $USER</p></blockquote><h4 id="6-测试-Docker-是否安装正确"><a href="#6-测试-Docker-是否安装正确" class="headerlink" title="6. 测试 Docker 是否安装正确"></a>6. 测试 Docker 是否安装正确</h4><blockquote><p>$ sudo docker run hello-world</p><p>Unable to find image ‘hello-world:latest’ locally<br>latest: Pulling from library/hello-world<br>ca4f61b1923c: Pull complete<br>Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c<br>Status: Downloaded newer image for hello-world:latest</p><p>Hello from Docker!<br>This message shows that your installation appears to be working correctly.</p><p>To generate this message, Docker took the following steps:</p><ol><li>The Docker client contacted the Docker daemon.</li><li>The Docker daemon pulled the “hello-world” image from the Docker Hub.<br>(amd64)</li><li>The Docker daemon created a new container from that image which runs the<br>executable that produces the output you are currently reading.</li><li>The Docker daemon streamed that output to the Docker client, which sent it<br>to your terminal.</li></ol><p>To try something more ambitious, you can run an Ubuntu container with:<br> $ docker run -it ubuntu bash</p><p>Share images, automate workflows, and more with a free Docker ID:<br> <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com/</a></p><p>For more examples and ideas, visit:<br> <a href="https://docs.docker.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/</a><br>如果出现以上界面，说明安装成功。</p></blockquote><h4 id="6-镜像加速"><a href="#6-镜像加速" class="headerlink" title="6. 镜像加速"></a>6. 镜像加速</h4><ul><li>ubuntu 14.04:<br>编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址,然后重新启动：  <blockquote><p>DOCKER_OPTS=”–registry-mirror=<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a><br>$ sudo service docker restart</p></blockquote></li><li>ubuntu 16.04:<br>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）:  <blockquote><p>{<br>  “registry-mirrors”: [</p><pre><code>&quot;https://registry.docker-cn.com&quot;</code></pre><p>  ]<br>}  </p></blockquote></li></ul><p>之后重新启动服务:  </p><blockquote><p>$ sudo systemctl daemon-reload<br>$ sudo systemctl restart docker</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ubuntu安装Docker-ce流程&quot;&gt;&lt;a href=&quot;#Ubuntu安装Docker-ce流程&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装Docker ce流程&quot;&gt;&lt;/a&gt;Ubuntu安装Docker ce流程&lt;/h2&gt;&lt;p&gt;实际
      
    
    </summary>
    
    
      <category term="工具学习" scheme="https://island123.github.io/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Docker" scheme="https://island123.github.io/tags/Docker/"/>
    
      <category term="环境搭建" scheme="https://island123.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="虚拟机" scheme="https://island123.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>QNAP固件解压及动态调试辅助脚本</title>
    <link href="https://island123.github.io/2019/03/14/2019-03-14-QNAP%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%8E%8B%E5%8F%8A%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC/"/>
    <id>https://island123.github.io/2019/03/14/2019-03-14-QNAP%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%8E%8B%E5%8F%8A%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2020-01-07T05:17:12.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="固件解压"><a href="#固件解压" class="headerlink" title="固件解压"></a>固件解压</h2><p>由于QNAP固件经过了加密，但是QNAP的密钥以及都一致为“QNAPNASVERSION4”，因此可利用公开工具qnap-utils对其固件进行解压,但在使用自动化工具之前，需要先编译好解密程序PC1放在相应目录下。按道理是可以先解密，再使用binwalk等工具进行解压，但我没有成功，我使用qnap-utils + PC1完成解压。</p><ol><li>Decrypt 镜像文件工具：<ul><li>解密 <a href="leanote://file/getAttach?fileId=5c85011e396be709b300000a">pc1.c</a><ul><li>decrypt工具</li><li>编译 gcc pc1.c -o PC1</li><li>使用： PC1 d QNAPNASVERSION4 TS-401T_20081128-1.3.0.img decoced_firmware.tar.gz</li></ul></li><li>加密 <a href="leanote://file/getAttach?fileId=5c85011e396be709b300000b">pc1.c</a><ul><li>encrypt工具</li><li>编译： gcc pc2.c -o PC2</li><li>使用：<ul><li>PC1 e QNAPNASVERSION4 unencrypted.img encrypted.img  </li><li>PC2 TS-401T1.3.0.img </li></ul></li><li>PC2 retrieve the version number from the image name, so you must keep it the same as the original</li></ul></li></ul></li><li>使用自动化解压工具<a href="https://github.com/mb2020/qnap-utils" target="_blank" rel="noopener">qnap-utils</a></li></ol><ul><li>git clone <a href="https://github.com/mb2020/qnap-utils.git" target="_blank" rel="noopener">https://github.com/mb2020/qnap-utils.git</a></li><li>将编译好的PC1放在/sbin/目录下</li><li>./extract_qnap_fw.sh firmware.img destdir</li><li>结果：<pre><code>* destdir/fw              files extracted from the firmware.img* destdir/sysroot         unpacked initrd/initramfs, rootfs2, rootfs_ext* destdir/qpkg            unpacked qpkg.tar</code></pre></li></ul><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><h3 id="辅助脚本"><a href="#辅助脚本" class="headerlink" title="辅助脚本"></a>辅助脚本</h3><ol><li><p>search_lib.sh<br>  descripition: 用于寻找utilRequest.cgi中的某个导入函数的实现的动态库</p><pre><code>使用方法：bash search_lib.sh Function_Name  Eg:  </code></pre><ul><li><p>bash search_lib.sh CGI_Get_Input   </p></li><li><p>输出： /root/disk1/QNAPTS431P2/firm/sysroot/usr/lib/libuLinux_cgi.so.0</p></li></ul></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">funName=<span class="variable">$1</span></span><br><span class="line">cgiName=<span class="string">'utilRequest.cgi'</span></span><br><span class="line">cgiPath=<span class="string">'/root/disk1/QNAPTS431P2/firm/sysroot/home/httpd/cgi-bin/filemanager'</span></span><br><span class="line">libPath_array=(<span class="string">'/root/disk1/QNAPTS431P2/firm/sysroot/lib'</span> <span class="string">'/root/disk1/QNAPTS431P2/firm/sysroot/usr/lib'</span> <span class="string">'/root/disk1/QNAPTS431P2/firm/sysroot/usr/local/lib'</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sos=$(readelf -d <span class="variable">$cgiPath</span><span class="string">"/"</span><span class="variable">$cgiName</span> | grep Shared | awk <span class="string">'&#123;print $5&#125;'</span> |  sed -r <span class="string">"s/\[(.*)\]/\1/g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> libFile <span class="keyword">in</span> <span class="variable">$sos</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    tmpFile=0</span><br><span class="line">    <span class="keyword">for</span> libPath <span class="keyword">in</span> <span class="variable">$&#123;libPath_array[@]&#125;</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        totalibFile=<span class="variable">$libPath</span><span class="string">"/"</span><span class="variable">$libFile</span></span><br><span class="line">        <span class="keyword">if</span> [ -e <span class="variable">$totalibFile</span> ]</span><br><span class="line">        <span class="keyword">then</span> </span><br><span class="line">            tmpFile=<span class="variable">$totalibFile</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$&#123;#tmpFile&#125;</span> -eq 0 ]</span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$libFile</span><span class="string">' not found'</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result=$(readelf -sWD <span class="variable">$tmpFile</span> | grep <span class="variable">$funName</span>)</span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$&#123;#result&#125;</span> -ne 0 ]</span><br><span class="line">        <span class="keyword">then</span> </span><br><span class="line">            tmp=$(<span class="built_in">echo</span> <span class="variable">$result</span> | awk <span class="string">'&#123;print $3&#125;'</span> | grep -v 00000000) <span class="comment"># $3, addrexists, suggest the func is here </span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="variable">$&#123;#tmp&#125;</span> -ne 0 ]</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="comment">#echo $result</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$tmpFile</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>calc_lib_addr<br>  Descripition: 程序运行时，通过程序名以及lib库中的偏移地址计算lib中绝对地址。  <pre><code>Func: bash calc_lib_addr.sh lib_name offset_addr  Eg:</code></pre></li></ol><pre><code>&gt; bash calc_lib_addr.sh libuLinux_cgi.so.0.0 0x000037D2  &gt; **输出：**   &gt; libuLinux_cgi.so.0.0\&apos;s base is 76e0b000    &gt; 0x76e0e7d2    </code></pre><ol start="3"><li>动态调试脚本：</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> PATH_INFO=<span class="string">"/cgi-bin/cgi.cgi"</span></span><br><span class="line"><span class="built_in">export</span> HTTP_HOST=<span class="string">"127.0.0.1:8080"</span></span><br><span class="line"><span class="built_in">export</span> REQUEST_METHOD=<span class="string">'GET'</span></span><br><span class="line"><span class="built_in">export</span> QUERY_STRING=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">export</span> REMOTE_ADDR=<span class="string">"192.168.1.1"</span></span><br><span class="line"><span class="built_in">export</span> REQUEST_URI=<span class="string">"/cgi-bin/cgi.cgi"</span></span><br><span class="line">LD_LIBRARY_PATH=./usr/<span class="built_in">local</span>/lib ./gdbserver-7.7.1 0.0.0.0:1222 ./home/httpd/cgi-bin/cgi.cgi</span><br></pre></td></tr></table></figure></div><p>运行脚本如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh cgi_script/authLogin_get.sh <span class="string">"c=wget 192.168.1.108;&amp;a=hh&amp;p=hh&amp;pp=hh&amp;u=hhh&amp;u=hhh&amp;p=hhh&amp;o=1233"</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;固件解压&quot;&gt;&lt;a href=&quot;#固件解压&quot; class=&quot;headerlink&quot; title=&quot;固件解压&quot;&gt;&lt;/a&gt;固件解压&lt;/h2&gt;&lt;p&gt;由于QNAP固件经过了加密，但是QNAP的密钥以及都一致为“QNAPNASVERSION4”，因此可利用公开工具qnap-u
      
    
    </summary>
    
    
      <category term="设备分析" scheme="https://island123.github.io/categories/%E8%AE%BE%E5%A4%87%E5%88%86%E6%9E%90/"/>
    
    
      <category term="QNAP" scheme="https://island123.github.io/tags/QNAP/"/>
    
      <category term="动态调试" scheme="https://island123.github.io/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    
      <category term="辅助脚本" scheme="https://island123.github.io/tags/%E8%BE%85%E5%8A%A9%E8%84%9A%E6%9C%AC/"/>
    
      <category term="固件解压" scheme="https://island123.github.io/tags/%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>retdec IDA mips反编译插件安装</title>
    <link href="https://island123.github.io/2019/03/14/2019-03-14-retdec-IDA-mips%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>https://island123.github.io/2019/03/14/2019-03-14-retdec-IDA-mips%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2020-01-07T05:17:22.712Z</updated>
    
    <content type="html"><![CDATA[<ul><li>retdec官网:<a href="https://retdec.com/idaplugin/" target="_blank" rel="noopener"> Retdec官网</a>  </li><li>retdec-idaplugin github: <a href="https://github.com/avast-tl/retdec-idaplugin" target="_blank" rel="noopener"> rtdec-idaplugin</a><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2>Retdec可以按如下方式使用</li></ul><ol><li>独立的Retdec:可以自己编译，<a href="https://github.com/avast-tl/retdec/releases" target="_blank" rel="noopener">也可以下载安装编译好的程序</a></li><li>Retdec IDA插件：需要独立的Retdec软件安装后才可以使用<h2 id="二、要求"><a href="#二、要求" class="headerlink" title="二、要求"></a>二、要求</h2>Retdec及其插件适用于windows以及linux系统，由于本人使用IDA的环境主要在windows环境下，故以下安装步骤根据windows展开。  <h3 id="IDA版本要求"><a href="#IDA版本要求" class="headerlink" title="IDA版本要求"></a>IDA版本要求</h3></li></ol><ul><li>适用IDA版本：7.*</li><li>插件本身使用64bit，但目前只支持32位程序的反编译（适用于ida而不是ida64）<h3 id="python版本要求"><a href="#python版本要求" class="headerlink" title="python版本要求"></a>python版本要求</h3></li><li>python版本要求：3.*</li><li>IDA插件使用python3以下命令（按顺序）,需要确保可用<ul><li>python3</li><li>py -3</li><li>python<h3 id="windows系统版本要求"><a href="#windows系统版本要求" class="headerlink" title="windows系统版本要求"></a>windows系统版本要求</h3></li></ul></li><li>windows系统版本：win7及之后，需要安装MSVC2016 runtime<h2 id="三、安装步骤"><a href="#三、安装步骤" class="headerlink" title="三、安装步骤"></a>三、安装步骤</h2></li></ul><ol><li>下载并解压适合自己系统的独立<a href="https://github.com/avast-tl/retdec/releases" target="_blank" rel="noopener">Retdec </a></li><li>安装<a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=48145" target="_blank" rel="noopener">Microsoft Visual C++ Redistributable for Visual Studio 2015</a></li><li>安装python3.x</li><li>安装<a href="https://github.com/upx/upx/releases/tag/v3.95" target="_blank" rel="noopener">UPX</a>，[选装，用于破壳]  </li><li>安装<a href="https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi" target="_blank" rel="noopener">Graphviz</a>，[选装，用于生成流程图]</li><li>下载正确的<a href="https://github.com/avast-tl/retdec-idaplugin/releases" target="_blank" rel="noopener">retdec-idaplugin</a></li><li>解压retdec-idaplugin安装包，并复制retdec.dll到IDA的plugin目录&lt;<ida_root>/plugins&gt;<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="四、运行效果"><a href="#四、运行效果" class="headerlink" title="四、运行效果"></a>四、运行效果</h2><a href="https://note.youdao.com/yws/public/resource/eeb3bf39a8d99d737791f6ad5a9cc6c8/xmlnote/C135E5C675204648B1C03FB279EF75AF/2000" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="https://note.youdao.com/yws/public/resource/eeb3bf39a8d99d737791f6ad5a9cc6c8/xmlnote/C135E5C675204648B1C03FB279EF75AF/2000" class="lazyload"></a></ida_root></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;retdec官网:&lt;a href=&quot;https://retdec.com/idaplugin/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Retdec官网&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;retdec-idaplugin github: &lt;
      
    
    </summary>
    
    
      <category term="工具学习" scheme="https://island123.github.io/categories/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="IDA plugin" scheme="https://island123.github.io/tags/IDA-plugin/"/>
    
      <category term="mips" scheme="https://island123.github.io/tags/mips/"/>
    
      <category term="反编译" scheme="https://island123.github.io/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>使用qemu建立多种架构虚拟机</title>
    <link href="https://island123.github.io/2019/03/14/2019-03-14-%E4%BD%BF%E7%94%A8qemu%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%A7%8D%E6%9E%B6%E6%9E%84%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://island123.github.io/2019/03/14/2019-03-14-%E4%BD%BF%E7%94%A8qemu%E5%BB%BA%E7%AB%8B%E5%A4%9A%E7%A7%8D%E6%9E%B6%E6%9E%84%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2020-02-10T03:26:43.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>qemu可用于创建mips,mipsel，arm等架构虚拟机  。</p><h2 id="下载虚拟机内核文件系统文件"><a href="#下载虚拟机内核文件系统文件" class="headerlink" title="下载虚拟机内核文件系统文件"></a>下载虚拟机内核文件系统文件</h2><p><a href="https://people.debian.org/~aurel32/qemu/" target="_blank" rel="noopener">下载地址：https://people.debian.org/~aurel32/qemu/</a></p><h2 id="虚拟机开启命令"><a href="#虚拟机开启命令" class="headerlink" title="虚拟机开启命令"></a>虚拟机开启命令</h2><h3 id="mips"><a href="#mips" class="headerlink" title="mips"></a><strong>mips</strong></h3><p><strong>32位：</strong>  </p><p><code>qemu-system-mips -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code> </p><p><strong>64位：</strong>  </p><p><code>qemu-system-mips64 -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code></p><h3 id="mipsel"><a href="#mipsel" class="headerlink" title="mipsel"></a>mipsel</h3><p><strong>32位：</strong>  </p><p><code>qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code></p><p><strong>64位</strong>  </p><p><code>qemu-system-mips64el -M malta -kernel vmlinux-3.2.0-4-5kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap -nographic</code></p><h3 id="armel"><a href="#armel" class="headerlink" title="armel"></a>armel</h3><p><code>qemu-system-arm -M versatilepb -kernel vmlinuz-3.2.0-4-versatile -initrd initrd.img-3.2.0-4-versatile -hda debian_wheezy_armel_standard.qcow2 -append &quot;root=/dev/sda1&quot; -net nic -net tap -nographic</code></p><h3 id="armhf"><a href="#armhf" class="headerlink" title="armhf"></a>armhf</h3><p><code>qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append &quot;root=/dev/mmcblk0p2&quot; -net nic -net tap -nographic</code></p><h3 id="arm64"><a href="#arm64" class="headerlink" title="arm64"></a>arm64</h3><p><code>qemu-system-x86_64 -hda debian_wheezy_amd64_standard.qcow2 -net nic -net tap -nographic</code></p><h2 id="配置虚拟机网络"><a href="#配置虚拟机网络" class="headerlink" title="配置虚拟机网络"></a>配置虚拟机网络</h2><ul><li><p>安装依赖文件</p><p><code>sudo apt-get install bridge-utils uml-utilities</code></p></li><li><p>修改 ubuntu主机网络配置，将ubuntu主机系统中的网络接口配置文件 <strong>/etc/network/interfaces</strong> 修改为如下内容并保存、关闭。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line">auto eth0 </span><br><span class="line">iface eth0 inet dhcp </span><br><span class="line"> </span><br><span class="line"><span class="comment">#auto br0 </span></span><br><span class="line">iface br0 inet dhcp </span><br><span class="line">  bridge_ports eth0 </span><br><span class="line">  bridge_maxwait 0</span><br></pre></td></tr></table></figure></div></li><li><p>创建QEMU的网络接口启动脚本，重启网络使配置生效。使用如下命令，在 <strong>/etc/qemu-ifup</strong>的后面加入以下内容。</p><p><code>sudo gedit /etc/qemu-ifup</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Executing /etc/qemu-ifup"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Bringing <span class="variable">$1</span> for bridged mode..."</span></span><br><span class="line">sudo /sbin/ifconfig <span class="variable">$1</span> 0.0.0.0 promisc up</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Adding <span class="variable">$1</span> to br0..."</span></span><br><span class="line">sudo /sbin/brctl addif br0 <span class="variable">$1</span></span><br><span class="line">sleep 3</span><br></pre></td></tr></table></figure></div><p>保存 文件/etc/qemu-ifup 以后，赋予文件/etc/qemu-ifup 可执行权限，然后重启网络使所有的配置生效。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod a+x /etc/qemu-ifup</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重启网络使配置生效</span></span><br><span class="line">$ sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure></div></li><li><p>启动虚拟机</p><p>在本地ubuntu命令行终端，启动桥连网络。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifdown eth0</span><br><span class="line">sudo ifup br0</span><br></pre></td></tr></table></figure></div><p>执行下面的命令启动虚拟机(将内核和文件系统替换为你的)</p><p><code>$ sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic,macaddr=00:16:3e:00:00:01 -net tap -nographic</code></p></li><li><p>配置虚拟机网络</p><p>使用 “<strong>ifconfig -a</strong>“ 命令，网络已经分配了IP地址.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;qemu可用于创建mips,mipsel，arm等架构虚拟机  。&lt;/p&gt;
&lt;h2 id=&quot;下载虚拟机内核文件系统文件&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
      <category term="环境搭建" scheme="https://island123.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="虚拟机" scheme="https://island123.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="物联网" scheme="https://island123.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
      <category term="qemu" scheme="https://island123.github.io/tags/qemu/"/>
    
  </entry>
  
</feed>
